/*
 * convertapi
 *
 * Convert API lets you effortlessly convert file formats and types.
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package GoCloudmersiveDocumentConvertApiClient

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type EditHtmlApiService service

/* 
EditHtmlApiService Append an HTML tag to the HEAD section of an HTML Document
Appends an HTML tag to the HEAD section of an HTML document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param htmlTag The HTML tag to append.
 * @param optional nil or *EditHtmlHtmlAppendHeaderTagOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.

@return string
*/

type EditHtmlHtmlAppendHeaderTagOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlAppendHeaderTag(ctx context.Context, htmlTag string, localVarOptionals *EditHtmlHtmlAppendHeaderTagOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/head/append/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	localVarHeaderParams["htmlTag"] = parameterToString(htmlTag, "")
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Append a Heading to an HTML Document
Appends a heading to the end of an HTML document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param headingText The text content to be used in the header.
 * @param optional nil or *EditHtmlHtmlAppendHeadingOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.
     * @param "HeadingSize" (optional.Int32) -  Optional: The heading size number. Default is 1. Accepts values between 1 and 6.
     * @param "CssStyle" (optional.String) -  Optional: The CSS style for the heading.

@return string
*/

type EditHtmlHtmlAppendHeadingOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
	HeadingSize optional.Int32
	CssStyle optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlAppendHeading(ctx context.Context, headingText string, localVarOptionals *EditHtmlHtmlAppendHeadingOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/append/heading"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	localVarHeaderParams["headingText"] = parameterToString(headingText, "")
	if localVarOptionals != nil && localVarOptionals.HeadingSize.IsSet() {
		localVarHeaderParams["headingSize"] = parameterToString(localVarOptionals.HeadingSize.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CssStyle.IsSet() {
		localVarHeaderParams["cssStyle"] = parameterToString(localVarOptionals.CssStyle.Value(), "")
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Append an Image to an HTML Document from a URL
Appends an image to the end of an HTML document using a URL.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param imageUrl The URL for the image.
 * @param optional nil or *EditHtmlHtmlAppendImageFromUrlOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.
     * @param "CssStyle" (optional.String) -  Optional: CSS style for the image.

@return string
*/

type EditHtmlHtmlAppendImageFromUrlOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
	CssStyle optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlAppendImageFromUrl(ctx context.Context, imageUrl string, localVarOptionals *EditHtmlHtmlAppendImageFromUrlOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/append/image/from-url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	localVarHeaderParams["imageUrl"] = parameterToString(imageUrl, "")
	if localVarOptionals != nil && localVarOptionals.CssStyle.IsSet() {
		localVarHeaderParams["cssStyle"] = parameterToString(localVarOptionals.CssStyle.Value(), "")
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Append a Base64 Inline Image to an HTML Document
Appends a base64 inline image to the end of an HTML document from an input file or URL.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EditHtmlHtmlAppendImageInlineOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.
     * @param "ImageFile" (optional.Interface of *os.File) -  Optional: Image file to be appended as base64 inline image.
     * @param "ImageUrl" (optional.String) -  Optional: Image URL to be appended as base64 inline image.
     * @param "CssStyle" (optional.String) -  Optional: CSS style for the image.
     * @param "ImageExtension" (optional.String) -  Optional: The extension (JPG, PNG, GIF, etc.) of the image file. Recommended if uploading an imageFile directly, instead of using imageUrl. If no extension can be determined, will default to JPG.

@return string
*/

type EditHtmlHtmlAppendImageInlineOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
	ImageFile optional.Interface
	ImageUrl optional.String
	CssStyle optional.String
	ImageExtension optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlAppendImageInline(ctx context.Context, localVarOptionals *EditHtmlHtmlAppendImageInlineOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/append/image/inline"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ImageUrl.IsSet() {
		localVarHeaderParams["imageUrl"] = parameterToString(localVarOptionals.ImageUrl.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CssStyle.IsSet() {
		localVarHeaderParams["cssStyle"] = parameterToString(localVarOptionals.CssStyle.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.ImageExtension.IsSet() {
		localVarHeaderParams["imageExtension"] = parameterToString(localVarOptionals.ImageExtension.Value(), "")
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.ImageFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.ImageFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("imageFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Append a Paragraph to an HTML Document
Appends a paragraph to the end of an HTML document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param paragraphText The text content to be used in the paragraph.
 * @param optional nil or *EditHtmlHtmlAppendParagraphOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.
     * @param "CssStyle" (optional.String) -  Optional: The CSS style for the paragraph.

@return string
*/

type EditHtmlHtmlAppendParagraphOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
	CssStyle optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlAppendParagraph(ctx context.Context, paragraphText string, localVarOptionals *EditHtmlHtmlAppendParagraphOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/append/paragraph"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	localVarHeaderParams["paragraphText"] = parameterToString(paragraphText, "")
	if localVarOptionals != nil && localVarOptionals.CssStyle.IsSet() {
		localVarHeaderParams["cssStyle"] = parameterToString(localVarOptionals.CssStyle.Value(), "")
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Create a Blank HTML Document
Returns a blank HTML Document format file.  The file is blank, with no contents by default.  Use the optional input parameters to add various starting elements.  Use additional editing commands such as Append Header, Append Paragraph or Append Image from URL to populate the document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EditHtmlHtmlCreateBlankDocumentOpts - Optional Parameters:
     * @param "Title" (optional.String) -  Optional: The title of the HTML document
     * @param "CssUrl" (optional.String) -  Optional: A CSS style URL to be added to the document.
     * @param "CssInline" (optional.String) -  Optional: An inline CSS style to be added to the document.
     * @param "JavascriptUrl" (optional.String) -  Optional: Javascript URL to be added to the document.
     * @param "JavascriptInline" (optional.String) -  Optional: Inline Javascript to be added to the document.

@return string
*/

type EditHtmlHtmlCreateBlankDocumentOpts struct { 
	Title optional.String
	CssUrl optional.String
	CssInline optional.String
	JavascriptUrl optional.String
	JavascriptInline optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlCreateBlankDocument(ctx context.Context, localVarOptionals *EditHtmlHtmlCreateBlankDocumentOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/create/blank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Title.IsSet() {
		localVarHeaderParams["title"] = parameterToString(localVarOptionals.Title.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CssUrl.IsSet() {
		localVarHeaderParams["cssUrl"] = parameterToString(localVarOptionals.CssUrl.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CssInline.IsSet() {
		localVarHeaderParams["cssInline"] = parameterToString(localVarOptionals.CssInline.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.JavascriptUrl.IsSet() {
		localVarHeaderParams["javascriptUrl"] = parameterToString(localVarOptionals.JavascriptUrl.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.JavascriptInline.IsSet() {
		localVarHeaderParams["javascriptInline"] = parameterToString(localVarOptionals.JavascriptInline.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Gets the language for the HTML document
Retrieves the language code (e.g. \&quot;en\&quot; or \&quot;de\&quot;) of an HTML document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EditHtmlHtmlGetLanguageOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.

@return HtmlGetLanguageResult
*/

type EditHtmlHtmlGetLanguageOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlGetLanguage(ctx context.Context, localVarOptionals *EditHtmlHtmlGetLanguageOpts) (HtmlGetLanguageResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HtmlGetLanguageResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/head/get/language"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v HtmlGetLanguageResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Extract resolved link URLs from HTML File
Extracts the resolved link URLs, fully-qualified if possible, from an input HTML file.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EditHtmlHtmlGetLinksOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.
     * @param "BaseUrl" (optional.String) -  Optional: Base URL of the page, such as https://mydomain.com

@return HtmlGetLinksResponse
*/

type EditHtmlHtmlGetLinksOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
	BaseUrl optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlGetLinks(ctx context.Context, localVarOptionals *EditHtmlHtmlGetLinksOpts) (HtmlGetLinksResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HtmlGetLinksResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/extract/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.BaseUrl.IsSet() {
		localVarHeaderParams["baseUrl"] = parameterToString(localVarOptionals.BaseUrl.Value(), "")
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v HtmlGetLinksResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Gets the rel canonical URL for the HTML document
Gets the rel canonical URL of an HTML document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EditHtmlHtmlGetRelCanonicalOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.

@return HtmlGetRelCanonicalUrlResult
*/

type EditHtmlHtmlGetRelCanonicalOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlGetRelCanonical(ctx context.Context, localVarOptionals *EditHtmlHtmlGetRelCanonicalOpts) (HtmlGetRelCanonicalUrlResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HtmlGetRelCanonicalUrlResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/head/get/rel-canonical-url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v HtmlGetRelCanonicalUrlResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Gets the sitemap URL for the HTML document
Gets the sitemap link URL of an HTML document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EditHtmlHtmlGetSitemapOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.

@return HtmlGetSitemapUrlResult
*/

type EditHtmlHtmlGetSitemapOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlGetSitemap(ctx context.Context, localVarOptionals *EditHtmlHtmlGetSitemapOpts) (HtmlGetSitemapUrlResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HtmlGetSitemapUrlResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/head/get/sitemap-url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v HtmlGetSitemapUrlResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Sets the language for the HTML document
Sets the language code of an HTML document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param languageCode The HTML langauge code to set.
 * @param optional nil or *EditHtmlHtmlSetLanguageOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.

@return string
*/

type EditHtmlHtmlSetLanguageOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlSetLanguage(ctx context.Context, languageCode string, localVarOptionals *EditHtmlHtmlSetLanguageOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/head/set/language"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	localVarHeaderParams["languageCode"] = parameterToString(languageCode, "")
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Sets the rel canonical URL for the HTML document
Sets the rel canonical URL of an HTML document.  This is useful for telling search engines and other indexers which pages are duplicates of eachother; any pages with the rel&#x3D;canonical tag will be treated as duplicates of the canonical URL.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param canonicalUrl The HTML canonical URL to set.
 * @param optional nil or *EditHtmlHtmlSetRelCanonicalOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.

@return string
*/

type EditHtmlHtmlSetRelCanonicalOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlSetRelCanonical(ctx context.Context, canonicalUrl string, localVarOptionals *EditHtmlHtmlSetRelCanonicalOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/head/set/rel-canonical-url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	localVarHeaderParams["canonicalUrl"] = parameterToString(canonicalUrl, "")
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EditHtmlApiService Sets the sitemap URL for the HTML document
Sets the sitemap URL of an HTML document.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sitemapUrl The HTML sitemap URL to set.
 * @param optional nil or *EditHtmlHtmlSetSitemapUrlOpts - Optional Parameters:
     * @param "InputFile" (optional.Interface of *os.File) -  Optional: Input file to perform the operation on.
     * @param "InputFileUrl" (optional.String) -  Optional: URL of a file to operate on as input.

@return string
*/

type EditHtmlHtmlSetSitemapUrlOpts struct { 
	InputFile optional.Interface
	InputFileUrl optional.String
}

func (a *EditHtmlApiService) EditHtmlHtmlSetSitemapUrl(ctx context.Context, sitemapUrl string, localVarOptionals *EditHtmlHtmlSetSitemapUrlOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/convert/edit/html/head/set/sitemap-url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.InputFileUrl.IsSet() {
		localVarHeaderParams["inputFileUrl"] = parameterToString(localVarOptionals.InputFileUrl.Value(), "")
	}
	localVarHeaderParams["sitemapUrl"] = parameterToString(sitemapUrl, "")
	var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.InputFile.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.InputFile.Value().(*os.File)
		if !localVarFileOk {
				return localVarReturnValue, nil, reportError("inputFile should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Apikey"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
